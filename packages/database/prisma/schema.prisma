// Prisma Schema for SyncHire MVP
// Database: PostgreSQL (Local for dev, GCP Cloud SQL for production)

generator client {
  provider = "prisma-client-js"
  // Using default output location for better bundler compatibility
}

generator json {
  provider  = "prisma-json-types-generator"
  namespace = "PrismaJson"
  // clientOutput uses default Prisma client location
}

datasource db {
  provider = "postgresql"
  // URL is configured in prisma.config.ts (Prisma 7 requirement)
}

// =============================================================================
// AUTHENTICATION (Better Auth compatible)
// =============================================================================

model User {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false) // Better Auth expects Boolean
  image         String?
  password      String?  // Better Auth: hashed password for email/password auth
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  accounts            Account[]
  sessions            Session[]
  cvUploads           CVUpload[]
  interviews          Interview[]
  applications        CandidateApplication[]
  notifications       Notification[]
  members             Member[] // User's org memberships
  jobsCreated         Job[]               @relation("JobCreator") // Jobs this user created
  invitations         Invitation[]        // Invitations sent by this user

  @@map("user")
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String    // Account ID from provider (or equal to userId for email/password)
  providerId            String    // Provider identifier (e.g., "google", "credential")
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?   @db.Text
  password              String?   // For credential provider (email/password)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
  @@map("account")
}

model Session {
  id                   String   @id @default(cuid())
  userId               String
  token                String   @unique // Better Auth session token
  expiresAt            DateTime
  ipAddress            String?
  userAgent            String?
  activeOrganizationId String? // Organization plugin: currently active org
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("session")
}

// Better Auth: Verification tokens for email verification, password reset, etc.
model Verification {
  id         String    @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt

  @@map("verification")
}

// =============================================================================
// ORGANIZATIONS
// =============================================================================

model Organization {
  id          String  @id @default(cuid())
  name        String
  slug        String  @unique // URL-friendly identifier: "acme-corp"
  logo        String?
  website     String?
  description String? @db.Text
  industry    String?
  size        String? // "1-10", "11-50", "51-200", "201-500", "501+"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members     Member[]
  jobs        Job[]
  invitations Invitation[]

  @@map("organization")
}

model Invitation {
  id             String   @id @default(cuid())
  email          String
  inviterId      String
  organizationId String
  role           String   @default("member")
  status         String   @default("pending") // pending, accepted, rejected, expired
  expiresAt      DateTime
  createdAt      DateTime @default(now())

  inviter      User         @relation(fields: [inviterId], references: [id])
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([organizationId])
  @@map("invitation")
}

model Member {
  id             String        @id @default(cuid())
  organizationId String
  userId         String
  role           OrgMemberRole @default(member)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@index([userId])
  @@map("member")
}

// Lowercase to match Better Auth's organization plugin
enum OrgMemberRole {
  owner
  admin
  member
}

// =============================================================================
// CV MANAGEMENT
// =============================================================================

model CVUpload {
  id         String   @id @default(cuid())
  userId     String
  fileName   String
  fileUrl    String // File URL (currently local path, will be migrated to GCP Cloud Storage)
  fileHash   String   @unique // SHA-256 hash of file content for deduplication
  fileSize   Int
  uploadedAt DateTime @default(now())

  /// [ExtractedCVData]
  extraction Json?

  user         User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  applications CandidateApplication[]

  @@index([userId])
  @@index([fileHash])
  @@map("cv_upload")
}

// =============================================================================
// JOBS
// =============================================================================

model Job {
  id              String    @id @default(cuid())
  title           String
  organizationId  String // Which organization owns this job
  createdById     String // Who created this job
  department      String?
  location        String
  employmentType  String // Full-time, Part-time, Contract, etc.
  workArrangement String? // Remote, Hybrid, On-site, Flexible
  salary          String?
  description     String    @db.Text
  requirements    String[]
  status          JobStatus @default(ACTIVE)

  // AI Matching settings
  aiMatchingEnabled   Boolean        @default(false)
  aiMatchingThreshold Int            @default(80)
  aiMatchingStatus    MatchingStatus @default(DISABLED)

  jdFileUrl    String?
  jdFileHash   String?
  /// [ExtractedJobData]
  jdExtraction Json?
  jdVersion    Json?

  postedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organization Organization           @relation(fields: [organizationId], references: [id])
  createdBy    User                   @relation("JobCreator", fields: [createdById], references: [id])
  questions    JobQuestion[]
  applications CandidateApplication[]
  interviews   Interview[]

  @@index([organizationId])
  @@index([createdById])
  @@index([status])
  @@index([aiMatchingStatus])
  @@map("job")
}

enum JobStatus {
  DRAFT
  ACTIVE
  CLOSED
}

enum MatchingStatus {
  DISABLED
  SCANNING
  COMPLETE
  FAILED
}

model JobQuestion {
  id        String       @id @default(cuid())
  jobId     String
  content   String       @db.Text
  type      QuestionType @default(SHORT_ANSWER)
  options   String[] // For MULTIPLE_CHOICE
  duration  Int          @default(2) // Duration in minutes
  category  String? // Optional category for grouping questions (e.g., "technical", "behavioral")
  required  Boolean      @default(true)
  order     Int
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@map("job_question")
}

enum QuestionType {
  SHORT_ANSWER
  LONG_ANSWER
  MULTIPLE_CHOICE
  SCORED
}

// =============================================================================
// APPLICATIONS
// =============================================================================

model CandidateApplication {
  id             String @id @default(cuid())
  jobId          String
  cvUploadId     String
  userId         String
  candidateName  String
  candidateEmail String

  matchScore   Int
  matchReasons String[]
  skillGaps    String[]
  status       ApplicationStatus @default(READY)
  source       ApplicationSource

  /// [InterviewQuestions]
  questionsData Json?

  interviewId String?  @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  job       Job        @relation(fields: [jobId], references: [id], onDelete: Cascade)
  cvUpload  CVUpload   @relation(fields: [cvUploadId], references: [id])
  user      User       @relation(fields: [userId], references: [id])
  interview Interview? @relation(fields: [interviewId], references: [id])

  @@unique([jobId, userId]) // One application per job per user
  @@index([jobId])
  @@index([userId])
  @@index([status])
  @@map("candidate_application")
}

enum ApplicationStatus {
  MATCHING
  GENERATING_QUESTIONS
  READY
  INTERVIEWING
  COMPLETED
  REJECTED
}

enum ApplicationSource {
  AI_MATCH
  MANUAL_APPLY
}

// =============================================================================
// INTERVIEWS
// =============================================================================

model Interview {
  id          String @id @default(cuid())
  jobId       String
  candidateId String

  status          InterviewStatus @default(PENDING)
  callId          String?         @unique
  transcript      String?         @db.Text
  score           Int?
  durationMinutes Int             @default(0)

  /// [AIEvaluation]
  aiEvaluation Json?

  createdAt   DateTime  @default(now())
  completedAt DateTime?

  job           Job                   @relation(fields: [jobId], references: [id], onDelete: Cascade)
  candidate     User                  @relation(fields: [candidateId], references: [id])
  application   CandidateApplication?
  interviewCall InterviewCall?

  @@index([jobId])
  @@index([candidateId])
  @@index([callId])
  @@map("interview")
}

enum InterviewStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  TRANSCRIPT_MISSING
  ANALYSIS_FAILED
}

// =============================================================================
// NOTIFICATIONS
// =============================================================================

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType @default(INFO)
  title     String
  message   String           @db.Text
  read      Boolean          @default(false)
  actionUrl String?
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@map("notification")
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
}

// =============================================================================
// INTERVIEW CALL TRACKING (replaces in-memory Map)
// =============================================================================

model InterviewCall {
  id                 String    @id @default(cuid())
  callId             String    @unique
  interviewId        String    @unique
  videoAvatarEnabled Boolean   @default(false)
  agentInvited       Boolean   @default(false)
  agentJoinedAt      DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  interview Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)

  @@index([callId])
  @@map("interview_call")
}
